# TOP FORTH  #

## A) Forth 基本特性

   1. Forth 是 場域應用系統 使用者 或 程式語言 初學者 容易使用
      並且 容易用以設計 場域應用系統 的 語言。

   2. Forth 是 程式語言 開發者 容易輕鬆建制 的 系統, 從無到有 (Bottom Up)
      或者 從既有到更豐富 (Top Up)。

## B) 對 Forth 的期許

   1. Forth 應該永遠是 場域應用系統 使用者 或 程式語言 初學者 方便的工具。

   2. Forth 應該永遠是 場域應用系統 使用者 與 開發者 隨時代進步而日新月異的
      方便工具 (善用既有豐富資源)。

## C) TOP FORTH

   Forth 應該就是 站在巨人肩膀 (On Top, 在既有 豐富資源的語言環境上, 例如 js), 
   充分 發揮 Forth 本能, 輕鬆創造 應用新指令 的 Top Up 發展系統。 這樣的 Forth 
   或許可以 稱作 TOP FORTH。

## D) oneWordVM.js

   oneWordVM.js 中 f = new  oneWordVM(); 這 js 指令 預設 f 為僅有 1 個指令 (Forth Word)  
   的 TOP FORTH 核心引擎。 這僅有的指令叫作 "code", 有了這指令 就可 定義出許多新指令 (Forth Word) 分別去執行 任何形式的 js code。

## E) f.eval(script)

   f.eval(script) 這 js 指令 可依序執行 script 中 以空白區隔的每個字串, f.token。
   
   1. 若 f.token 是 Forth Word, 就直接執行。 
   2. 若 f.token 是一個 number (不管是 10 進制 float 或是 任何進制 int), 就放到 資料堆疊 備用。 
   3. 若 f.token 是一個 js object, 不管是 string, list, pointer, … 等, 也放到 資料堆疊 備用。
   4. 否則, 就宣稱 這 f.token 字串 為 "unDef", 並停止其餘 token 的處理。

   
## F) 用 code 定義 Forth Word

   現在說明 在 script 中, 怎樣可以用 code 來定義一個 Forth Word, 其語法如下。 
   
   1. code 之後 是 Forth Word 的名稱 (可為任何字串, 可包含任何符號)。 
   2. 隨後 可接一個圓括弧註解 (左右圓括弧間)。 兩個減號前 代表這 Forth Word 執行時
      會從資料堆疊上取用的項目; 兩個減號後 代表 執行後 資料堆疊上會留下的項目。
   3. 之後到 end-code 間 為這 Forth Word 所要執行的 js script。
   
   例如:
	
	f.eval(
	`code bl ( -- 32 ) // 空白 字元的 ASCII 碼 32 (存到 資料堆疊 f.dStk)。
		f.dStk.push(32);
	 end-code
	`);
		
   這樣 就定義了一個 名稱為 bl 的 Forth Word。 執行這 Forth Word 也就是執行 js 指令
   f.dStk.push(32); (將空白 字元的 ASCII 碼 32 放上 資料堆疊 備用)。
   
## G) Forth Word 範例
		
	code quote ( -- 34 ) // 雙引號 字元的 ASCII 碼 34 (存到 資料堆疊 f.dStk)。
		f.dStk.push(34); end-code
		
	code space ( -- ) // 印出 空白字元 (其實並未真正印出, 乃是存到 輸出暫存區 f.tob)。
		f.tob+=" "; end-code
	
	code print ( dataItem -- ) // 印出 資料堆疊上的項目 (轉成字串 存到 輸出暫存區 f.tob)。
		f.tob+=f.dStk.pop(); end-code
		
	code . ( dataItem -- ) // 印出 資料堆疊上的項目 (轉成字串) 並多印一個空白。
		f.tob+=f.dStk.pop()+" "; end-code
		
	code emit ( ASCII -- ) // 印出 ASCII 碼 對應字元 (存到 輸出暫存區 f.tob)。
		f.tob+=String.fromCharCode(f.dStk.pop()); end-code
		
	code cr ( -- ) // 印出 輸出暫存區 f.tob 字串, 然後清空 f.tob (準備存之後要輸出的字串)。
		console.log(f.tob), f.tob=""; end-code
		
	code + ( a b -- a+b ) // 取資料堆疊頂端兩項 (number, string, 或其他) 相加, 留結果在堆疊。
		var s=f.dStk, t=s.pop(); s[s.length-1]+=t; end-code
		
	code - ( a b -- a-b ) // 取資料堆疊頂端兩數相減, 留結果在堆疊。
		var s=f.dStk, t=s.pop(); s[s.length-1]-=t; end-code
		
	code * ( a b -- a*b ) // 取資料堆疊頂端兩數相乘, 留結果在堆疊。
		var s=f.dStk, t=s.pop(); s[s.length-1]*=t; end-code
		
	code / ( a b -- a/b ) // 取資料堆疊頂端兩數相除, 留商數在堆疊。
		var s=f.dStk, t=s.pop(); s[s.length-1]/=t; end-code
		
	code mod ( a b -- a%b ) // 取資料堆疊頂端兩數相除, 留餘數在堆疊。
		var s=f.dStk, t=s.pop(); s[s.length-1]%=t; end-code
		
	code or ( a b -- a|b ) // 取資料堆疊頂端兩數 執行 bitwise OR, 留結果在堆疊。
		var s=f.dStk, t=s.pop(); s[s.length-1]|=t; end-code
		
	code and ( a b -- a&b ) // 取資料堆疊頂端兩數 執行 bitwise AND, 留結果在堆疊。
		var s=f.dStk, t=s.pop(); s[s.length-1]&=t; end-code
		
	code xor ( a b -- a^b ) // 取資料堆疊頂端兩數 執行 bitwise XOR, 留結果在堆疊。
		var s=f.dStk, t=s.pop(); s[s.length-1]^=t; end-code
		
	code = ( a b -- a==b ) // 取資料堆疊頂端兩項 看是否相等, 留下 true 或 false。
		var s=f.dStk, t=s.pop(); s[s.length-1]=s[s.length-1]==t; end-code
		
	code <> ( a b -- a==b ) // 取資料堆疊頂端兩項 看是否不等, 留下 true 或 false。
		var s=f.dStk, t=s.pop(); s[s.length-1]=s[s.length-1]!=t; end-code
		
	code < ( a b -- a<b ) // 取資料堆疊頂端兩項 看是否前項小於後項, 留下 true 或 false。
		var s=f.dStk, t=s.pop(); s[s.length-1]=s[s.length-1]<t; end-code
		
	code > ( a b -- a>b ) // 看資料堆疊頂端兩項 前項是否大於後項, 留下 true 或 false。
		var s=f.dStk, t=s.pop(); s[s.length-1]=s[s.length-1]>t; end-code
		
	code <= ( a b -- a<=b ) // 看資料堆疊頂端兩項 前項是否不大於後項, 留下 true 或 false。
		var s=f.dStk, t=s.pop(); s[s.length-1]=s[s.length-1]<=t; end-code
		
	code >= ( a b -- a>=b ) // 看資料堆疊頂端兩項 前項是否不小於後項, 留下 true 或 false。
		var s=f.dStk, t=s.pop(); s[s.length-1]=s[s.length-1]>=t; end-code
		
	code true ( -- true ) // 將 true 放上 資料堆疊。
		f.dStk.push(true); end-code
		
	code false ( -- false ) // 將 false 放上 資料堆疊。
		f.dStk.push(false); end-code

G) 堆疊操作

   dup、swap、drop … 這些 堆疊操作指令 不是 forth 吸引人的特點, 我們不該太過強調他們。就算沒有 應該也沒關係吧。
   不過, 我們還是可以 將這些 Forth 標準指令 當作範例 加入系統, 如下。
   
	code dup ( a -- a a ) // 資料堆疊頂端項目 複製
		var s=f.dStk, a=s[s.length-1]; s.push(a); end-code
	
	code swap ( a b -- b a ) // 資料堆疊頂端兩項目 位置對調
		var s=f.dStk, n=s.length, b=s[n-1]; s[n-1]=s[n-2]; s[n-2]=b; end-code;
	
	code drop ( a -- ) // 資料堆疊頂端項目 丟棄
		f.dStk.length--;
   
	code over ( a b -- a b a ) // 資料堆疊頂端次項 複製
		var s=f.dStk, a=s[s.length-2]; s.push(a); end-code
   
	code rot ( a b c -- b c a ) // 資料堆頂三項 位置轉動
		var s=f.dStk, n=s.length, a=s[n-3];
		s[n-3]=s[n-2]; s[n-2]=s[n-1]; s[n-1]=a; end-code
   
	code -rot ( a b c -- c a b ) // 資料堆頂三項 位置反轉
		var s=f.dStk, n=s.length, c=s[n-1];
		s[n-1]=s[n-2]; s[n-2]=s[n-3]; s[n-3]=c; end-code
		
	code pick ( ni .. n2 n1 n0 i == ni .. n2 n1 n0 ni )
		var s=f.dStk, i=s.pop(); s.push(s[i]); end-code
   
	code roll ( ni .. n2 n1 n0 i == .. n2 n1 n0 ni )
		var s=f.dStk, i=s.pop(), n=s.length, ni=s[n-i];
		while(i>1)s[n-i]=s[n-(--i)]; s[n-1]=ni; end-code
   
   還有一些常見的堆疊操作指令