<script src="02_Adding 2D content to a WebGL context_files/gl-matrix.js"></script>
<canvas id="canvas" width="200" height="200"></canvas>
<script>
var vertices = [ // 正立方體
// 8 個頂點 每個點 xyz 座標 與 rgb 顏色
  -1, -1, -1,     0.0, 0.0, 0.0,   // p00 LDB
   1, -1, -1,     1.0, 0.0, 0.0,   // p01 RDB
  -1,  1, -1,     0.0, 1.0, 0.0,   // p02 LTB
   1,  1, -1,     1.0, 1.0, 0.0,   // p03 RTB
  -1, -1,  1,     0.0, 0.0, 1.0,   // p04 LDF
   1, -1,  1,     1.0, 0.0, 1.0,   // p05 RDF
  -1,  1,  1,     0.0, 1.0, 1.0,   // p06 LTF
   1,  1,  1,     1.0, 1.0, 1.0,   // p07 BTF
// x 軸 端點
  -1,  0,  0,     0.0, 0.7, 0.7,   // p08 L
   1,  0,  0,     1.0, 0.7, 0.7,   // p09 R
// y 軸 端點
   0, -1,  0,     0.7, 0.0, 0.7,   // p10  D
   0,  1,  0,     0.7, 1.0, 0.7,   // p11  T
// z 軸 端點
   0,  0, -1,     0.7, 0.7, 0.0,   // p12   B
   0,  0,  1,     0.7, 0.7, 1.0,   // p13   F
];

var indices = [ // 正立方體 8 頂點 每 2 頂點連線 (對角除外)
  0,1,  0,2,  0,3,  0,4,  0,5,  0,6,/*0,7,*/
  1,2,  1,3,  1,4,  1,5,/*1,6,*/1,7,
  2,3,  2,4,/*2,5,*/2,6,  2,7,
/*3,4,*/3,5,  3,6,  3,7,
  4,5,  4,6,  4,7,
  5,6,  5,7,
  6,7,
  8,9,  10,11,  12,13, // x, y, z 軸線 端點連線
];

function initGL() {
   var gl = canvas.getContext('webgl');
   gl.enable(gl.DEPTH_TEST); // 開啟【前景遮蔽後景】效果
   gl.viewport(0, 0, canvas.width, canvas.height); // 顯示整張畫布
   gl.clearColor(.5, .5, .5, 1); // 以灰色設定為背景
   return gl;
}

var vSrc = `
attribute vec4 coords;
attribute vec4 colors;
varying vec4 varyingColors;
uniform mat4 u_perspectiveMatrix;
uniform mat4 u_transformMatrix;
void main() {
  gl_Position = u_perspectiveMatrix *
                u_transformMatrix *
                coords;
  varyingColors = colors;
}`;

var fSrc = `
precision mediump float;
varying vec4 varyingColors;
void main() {
  gl_FragColor = varyingColors;
}
`;

function createVShader(gl, vSrc) {
  var vShd = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vShd, vSrc);
  gl.compileShader(vShd);
  return vShd;
}

function createFShader(gl, fSrc) {
  var fShd = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fShd, fSrc);
  gl.compileShader(fShd);
  return fShd;
}

function initShaders(gl, vSrc, fSrc) {
  var shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, createVShader(gl, vSrc));
  gl.attachShader(shaderProgram, createFShader(gl, fSrc));
  gl.linkProgram(shaderProgram);
  gl.useProgram(shaderProgram);
  return shaderProgram;
}

var matrix = mat4.create();
mat4.translate(matrix, matrix, [0, 0, -4]); // 座標移位

function createPoints(gl, program) {
  
  var buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(vertices),
                gl.STATIC_DRAW);
  
  var aCoords = gl.getAttribLocation(program, "coords");
  gl.vertexAttribPointer(aCoords, 3, gl.FLOAT, false,
                         Float32Array.BYTES_PER_ELEMENT * 6,
                         0);
  gl.enableVertexAttribArray(aCoords);
  
  var aColors = gl.getAttribLocation(program, "colors");
  gl.vertexAttribPointer(aColors, 3, gl.FLOAT, false,
                         Float32Array.BYTES_PER_ELEMENT * 6,
                         Float32Array.BYTES_PER_ELEMENT * 3);
  gl.enableVertexAttribArray(aColors);
  
  var perspectiveMatrix = mat4.create();
  mat4.perspective(perspectiveMatrix, 1,
                   canvas.width / canvas.height, 0.1, 11);
  var perspectiveLoc = gl.getUniformLocation(program,
                                             'u_perspectiveMatrix');
  gl.uniformMatrix4fv(perspectiveLoc, false, perspectiveMatrix);
}
function createIndices(gl) {
  var indexCount = indices.length;
  var indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                new Uint8Array(indices),
                gl.STATIC_DRAW);
  return indexCount;
}
function draw(gl, vertices, shaderProgram, indexCount) {
  gl.clear(gl.COLOR_BUFFER_BIT); // 以背景顏色清畫布
  mat4.rotateX(matrix, matrix, -0.007); // 座標轉軸
  mat4.rotateY(matrix, matrix,  0.013); // 座標轉軸
  mat4.rotateZ(matrix, matrix,  0.010); // 座標轉軸
  var transformMatrix = gl.getUniformLocation(shaderProgram, "u_transformMatrix");
  gl.uniformMatrix4fv(transformMatrix, false, matrix);
  
  gl.drawElements(gl.LINES, indexCount, gl.UNSIGNED_BYTE, 0);
  const bindDraw = (gl, vertices, shaderProgram, indexCount) => () => {
    draw(gl, vertices, shaderProgram, indexCount);
  }
  requestAnimationFrame(bindDraw(gl, vertices, shaderProgram, indexCount));
}
function main() {
  var gl = initGL();
  var shaderProgram = initShaders(gl, vSrc, fSrc);
  var vertices = createPoints(gl, shaderProgram);
  var indexCount = createIndices(gl);
  draw(gl, vertices, shaderProgram, indexCount);
}
main();
</script>